<!DOCTYPE html>
<html>
<head>
    <title>Benchmark Results</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <style>
        .diff { font-size: 9pt; color: #c0c0c0; }
        .numeric { text-align: right; }
        .summary { vertical-align: top; }
        </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.6/handlebars.min.js"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.bundle.min.js'></script>
    <style type="text/css">
tr.header {
    font-weight: bold;
}
td.numeric {
    font-family: monospace;
}
td.iteration::before {
    content: "#";
}
td.iteration {
    text-align: center;
}
td.warm-up {
    background-color: #fee;
}
tr:hover td.warm-up {
    background-color: #fdd;
}
td.measured {
    background-color: #efe;
}
tr:hover td.measured {
    background-color: #dfd;
}
    </style>
    <script>
const Phase = {
    WARM_UP: "warm-up",
    MEASURED: "measured"
};

let benchmarkResult = {
    scenarios: [{
        definition: {
            id: "file-system-watching@1",
            name: "file-system-watching",
            title: "File System Watching",
            buildTool: "Gradle",
            tasks: "assemble",
            problems: []
        },
        samples: [{
                name: "execution"
            },{
                name: "ResolveConfigurationDependenciesBuildOperationType"
            },{
                name: "FingerprintTransformInputsOperation"
            }
        ],
        iterations: [
            {
                id: "file-system-watching@1@1",
                phase: Phase.WARM_UP,
                iteration: 1,
                title: "warm-up build #1",
                results: {
                    "execution": 1234.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 123.4,
                    "FingerprintTransformInputsOperation": 132.2
                }
            },
            {
                id: "file-system-watching@1@2",
                phase: Phase.WARM_UP,
                iteration: 2,
                title: "warm-up build #2",
                results: {
                    "execution": 1224.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 113.4,
                    "FingerprintTransformInputsOperation": 142.2
                }
            },
            {
                id: "file-system-watching@1@3",
                phase: Phase.MEASURED,
                iteration: 1,
                title: "measured build #1",
                results: {
                    "execution": 924.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 93.4,
                    "FingerprintTransformInputsOperation": 92.2
                }
            },
            {
                id: "file-system-watching@1@4",
                phase: Phase.MEASURED,
                iteration: 2,
                title: "measured build #2",
                results: {
                    "execution": 824.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 83.4,
                    "FingerprintTransformInputsOperation": 82.2
                }
            },
            {
                id: "file-system-watching@1@4",
                phase: Phase.MEASURED,
                iteration: 3,
                title: "measured build #3",
                results: {
                    "execution": 724.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 73.4,
                    "FingerprintTransformInputsOperation": 72.2
                }
            },
        ]
    },{
        definition: {
            id: "configuration-cache@2",
            name: "configuration-cache",
            title: "Configuration Cache",
            buildTool: "Gradle",
            tasks: "assemble",
            problems: []
        },
        samples: [{
                name: "execution"
            },{
                name: "ResolveConfigurationDependenciesBuildOperationType"
            },{
                name: "FingerprintTransformInputsOperation"
            }
        ],
        iterations: [
            {
                id: "configuration-cache@2@1",
                phase: Phase.WARM_UP,
                iteration: 1,
                title: "warm-up build #1",
                results: {
                    "execution": 2234.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 123.4,
                    "FingerprintTransformInputsOperation": 132.2
                }
            },
            {
                id: "configuration-cache@2@2",
                phase: Phase.WARM_UP,
                iteration: 2,
                title: "warm-up build #2",
                results: {
                    "execution": 2224.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 113.4,
                    "FingerprintTransformInputsOperation": 142.2
                }
            },
            {
                id: "configuration-cache@2@3",
                phase: Phase.MEASURED,
                iteration: 1,
                title: "measured build #1",
                results: {
                    "execution": 1924.3,
                    "ResolveConfigurationDependenciesBuildOperationType": 93.4,
                    "FingerprintTransformInputsOperation": 92.2
                }
            },
        ]
    }]
};
    </script>
    <script id="data-table-template" type="text/x-handlebars-template">
    {{#with benchmarkResult}}
        <div class='row mt-5'>
            <div class='col'>
                <table class='table table-sm table-hover'>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Version</th>
                            <th>Tasks</th>
                        </tr>
                    </thead>
                    <tbody>
                        {{#each scenarios as |scenario|}}
                            <tr class="header">
                                {{#with scenario.definition}}
                                <td rowspan="{{ rows scenario }}">{{ title }}</td>
                                <td rowspan="{{ rows scenario }}">{{ buildTool }}</td>
                                <td rowspan="{{ rows scenario }}">{{ tasks }}</td>
                                {{/with}}
                                <td>Sample</td>
                                <td>Mean</td>
                                <td>Min</td>
                                <td>Median</td>
                                <td>Max</td>
                                {{#each scenario.iterations}}
                                    <td class="iteration {{ phase }}">{{ iteration }}</td>
                                {{/each}}
                            </tr>
                            {{#each samples as |sample|}}
                                <tr>
                                    <td>{{ sample.name }}</td>
                                    <td class="numeric">{{ calc 'mean' sample scenario }}</td>
                                    <td class="numeric">{{ calc 'min' sample scenario }}</td>
                                    <td class="numeric">{{ calc 'median' sample scenario }}</td>
                                    <td class="numeric">{{ calc 'max' sample scenario }}</td>
                                    {{#each scenario.iterations}}
                                        <td class="numeric {{ phase }}">{{lookup results sample.name }}</td>
                                    {{/each}}
                                </tr>
                            {{/each}}
                        {{/each}}
    <!--
            int maxRows = allScenarios.stream().mapToInt(v -> v.getResults().size()).max().orElse(0);
            for (int row = 0; row < maxRows; row++) {
                wxriter.write("<tr>");
                for (BuildScenarioResult<?> scenario : allScenarios) {
                    List<? extends BuildInvocationResult> results = scenario.getResults();
                    if (row >= results.size()) {
                        continue;
                    }
                    BuildInvocationResult buildResult = results.get(row);
                    wxriter.write("<td>");
                        wxriter.write(buildResult.getBuildContext().getDisplayName());
                        wxriter.write("</td>");
                    break;
                }
                for (BuildScenarioResult<?> scenario : allScenarios) {
                    writeRow(writer, scenario, row);
                }
                wxriter.write("</tr>\n");
            }

            statistic(writer, "mean", allScenarios, BuildScenarioResult.Statistics::getMean, true);
            statistic(writer, "min", allScenarios, BuildScenarioResult.Statistics::getMin, true);
            statistic(writer, "25th percentile", allScenarios, s -> s.getPercentile(25), true);
            statistic(writer, "median", allScenarios, BuildScenarioResult.Statistics::getMedian, true);
            statistic(writer, "75th percentile", allScenarios, s -> s.getPercentile(75), true);
            statistic(writer, "max", allScenarios, BuildScenarioResult.Statistics::getMax, true);
            statistic(writer, "stddev", allScenarios, BuildScenarioResult.Statistics::getStandardDeviation, false);
            statistic(writer, "confidence", allScenarios, BuildScenarioResult.Statistics::getConfidencePercent, false);
    -->
                    </tbody>
                </table>
            </div>
        </div>
{{/with}}
    </script>
</head>
<body>
<div class='container mt-5 mb-5'>
    <h1>Benchmark results</h1>

    <div class='row mt-5'>
        <div class='col ml-auto mr-auto'>
            <canvas id='samples' width='900' height='400'></canvas>
            </div>
        </div>
        <div id="data-table"></div>
    </div>
</div>
<script>
function iterations(scenario, phase) {
    return scenario.iterations.filter(iteration => iteration.phase === phase);
}
function iterationTitles() {
    return [...new Set(benchmarkResult.scenarios
        .map(scenario => scenario.iterations
            .map(iteration => iteration.title)
        )
        .flat()
    )];
}
function sort(array) {
    return array.slice().sort((a, b) => a - b);
}

Handlebars.registerHelper("rows", function(scenario) {
    return scenario.samples.length + 1;
});

const OPERATIONS = {
    "mean": (data) => data.reduce((sum, val) => sum += val) / data.length,
    "min": (data) => Math.min(...data),
    "max": (data) => Math.max(...data),
    "median": (data) => {
        let sorted = sort(data);
        const mid = Math.ceil(sorted.length / 2);
        return data.length % 2 == 0 ? (sorted[mid] + sorted[mid - 1]) / 2 : sorted[mid - 1];
    }
};
Handlebars.registerHelper("calc", function(operation, sample, scenario) {
    let data = iterations(scenario, Phase.MEASURED).map(iteration => iteration.results[sample.name]);
    return OPERATIONS[operation](data).toFixed(2);
});
let source = document.getElementById("data-table-template");
let target = document.getElementById("data-table");
let template = Handlebars.compile(source.innerHTML);
let maxIterations = Math.max(...(benchmarkResult.scenarios.map(scenario => scenario.iterations.length)));
let html = template({
    benchmarkResult: benchmarkResult,
    iterationTitles: iterationTitles(),
});
console.log(html);
target.innerHTML = html;
</script>
<script>
const COLORS = ["#527AB3", "#56ac76", "#f44336", "#d49c3e", "#211f2d"];
class PaletteGenerator {
    constructor(colors) {
        this.colors = COLORS.slice();
    }
    nextColor() {
        if (this.colors.length) {
            return this.colors.shift();
        } else {
            return "#8B899A";
        }
    }
};

function convertScenarioToChart(scenario, color) {
    return {
        label: `${scenario.definition.title} ${scenario.definition.buildTool}`,
        showLine: true,
        steppedLine: "middle",
        pointRadius: 5,
        fill: false,
        borderWidth: 3,
        pointBackgroundColor: color,
        borderColor: color,
        data: iterations(scenario, Phase.MEASURED)
            .map(iteration => iteration.results.execution)
    };
}

let ctx = document.getElementById('samples').getContext('2d');
let maxMeasuredIterations = Math.max(...(benchmarkResult.scenarios.map(scenario => iterations(scenario, Phase.MEASURED).length)));
let palette = new PaletteGenerator();
let chart = new Chart(ctx, {
    type: 'line',
    data: {
        labels: Array.from(Array(maxMeasuredIterations), (_, i) => (i + 1).toString()),
        datasets: benchmarkResult.scenarios.map(scenario => convertScenarioToChart(scenario, palette.nextColor()))
    },
    options: {
        responsive: false,
        scales: {
            yAxes: [{
                ticks: {
                    min: 0
                }
            }]
        }
    }
});
</script>

</body>
</html>
